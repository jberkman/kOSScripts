// launch.ks - Launch into a parking suborbital trajectory.
// Copyright Â© 2015 jacob berkman
// This file is distributed under the terms of the MIT license.

@lazyglobal off.

clearscreen.
print "DunaDirect Launch! v2.3".

parameter inclination is 0, rendezvous is false.

run once lib_dd.

function orbitalVelocity {
  parameter orbitable.
  parameter altitude.
  parameter a is orbitable:obt:semiMajorAxis.
  local r is altitude + orbitable:body:radius.
  return sqrt(orbitable:body:mu * ((2 / r) - (1 / a))).  
}

function launchPitch {
  local shipPitch is pitchForVec(ship, ship:velocity:surface).
  local goalHeight is 6 * body:atm:height / 7.
  if apoapsis > goalHeight / 2 {
    local pitch is 90 - 90 * min(1.05, 0.5 + (apoapsis - goalHeight / 2) / goalHeight).
    return clamp(pitch, -8 * pitchForVec(ship, ship:velocity:orbit), shipPitch + 10).
  }
  if apoapsis < goalHeight / 4 {
    return 90 - 30 * apoapsis / (goalHeight / 4).
  }
  return clamp(45, shipPitch - 2.5, shipPitch + 2.5).
}

function hasFlameout {
  local hasEngine is false.
  local hasUllage is false.
  local engs is 0.
  list engines in engs.
  for eng in engs {
    if eng:title:contains("ullage") or eng:title:contains("sepratron") or eng:tag:contains("ullage") {
      set hasUllage to hasUllage or eng:ignition.
    } else if eng:ignition and eng:flameout and not eng:multiMode {
      return true.
    } else if eng:ignition {
      set hasEngine to true.
    }
  }
  return maxThrust = 0 or (hasUllage and not hasEngine).
}

local launchHeading is 90 - inclination.
local launchAltitude is body:atm:height + 10000.
if rendezvous {
	set launchAltitude to target:orbit:semiMajorAxis - body:radius.
}

set ship:control:pilotmainthrottle to 0.
sas on.
if status = "prelaunch" {
  local preIgnite is false.
  for module in ship:modulesNamed("LaunchClamp") {
    if module:part:stage < stage:number - 1 {
      set preIgnite to true.
      break.
    }
  }
  print "T -".
  from { local count is 30. } until count = 0 step { set count to count - 1. wait 1. } do {
    print count + " " at(4, 1).
    if count = 15 {
      set warp to 0.
    }
    if count <= 10 {
      print char(7).
    }
    if preIgnite and count = 3 {
      print "Ignition.".
      global tIgnition is time:seconds.
      lock throttle to (time:seconds - tIgnition) / 4 + 0.5.
      stage.
    }
  }
  print 0 at(4, 1).
  stage.
  print "Liftoff!".
}
lock throttle to 1.
wait until verticalSpeed > 10.
sas off.
local lock lookAt to heading(launchHeading, 90).
local lock lookUp to heading(launchHeading, -45).
lock steering to lookdirup(lookAt:vector, lookUp:vector).

if body:atm:exists {
  wait until verticalSpeed > 50.
  lock targetPitch to goalPitch().
  lock lookAt to heading(launchHeading, launchPitch()).

  until altitude > body:atm:height {
    set warp to 0.
    wait until warp = 0.
    lock throttle to 1.
    until apoapsis > launchAltitude {
      wait until apoapsis > launchAltitude or hasFlameout().
      if hasFlameout() {
        wait 1.
      }
      until not hasFlameout() {
        wait 1.
        stage.
        wait 1. // give KW rockets time to spool up
      }
    }
    lock throttle to 0.
    wait until altitude > body:atm:height or apoapsis < body:atm:height + 5000.
  }
} else {
	wait until apoapsis > altitude + 1000 - alt:radar.
  lock lookAt to heading(launchHeading, 22.5).
  wait until apoapsis > launchAltitude.
}

lock throttle to 0.

if rendezvous {
	run dd_rendezvous.
} else {
  local goalSemiMajorAxis is body:radius + apoapsis.
  local initialVelocity is orbitalVelocity(ship, apoapsis).
  local goalVelocity is orbitalVelocity(ship, apoapsis, goalSemiMajorAxis).
  local deltaV is goalVelocity - initialVelocity.

  local burnTime is deltaVBurnTime(deltaV).
  lock burnStartTime to time:seconds + eta:apoapsis - burnTime / 2.

  print "burn time: " + round(burnTime) + " dV:" + round(deltaV).

  wait until time:seconds >= burnStartTime - 30.
  set warp to 0.
  lock burnPitch to -pitchForVec(ship, ship:prograde:forevector).
  lock steering to lookdirup(heading(launchHeading, burnPitch):vector, heading(launchHeading, -45):vector).

  wait until time:seconds >= burnStartTime.
  steerToDir().
  lock throttle to 1.

  wait until obt:semiMajorAxis >= goalSemiMajorAxis.

  lock throttle to 0.
  unlock steering.
  unlock throttle.
}
