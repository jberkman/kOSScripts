// launch.ks - Launch into a parking suborbital trajectory.
// Copyright Â© 2015 jacob berkman
// This file is distributed under the terms of the MIT license.

@lazyglobal off.

clearscreen.
print "DunaDirect Launch! v2.1".

parameter inclination is 0, rendezvous is false.

run once lib_dd_05k.

function orbitalVelocity {
  parameter orbitable.
  parameter altitude.
  parameter a is orbitable:obt:semiMajorAxis.
  local r is altitude + orbitable:body:radius.
  return sqrt(orbitable:body:mu * ((2 / r) - (1 / a))).  
}

function launchPitch {
  local shipPitch is pitchForVec(ship, ship:velocity:surface).
  local goalHeight is 6 * body:atm:height / 7.
  if apoapsis > goalHeight / 2 {
    local pitch is 90 - 90 * min(1.05, 0.5 + (apoapsis - goalHeight / 2) / goalHeight).
    return clamp(pitch, -8 * pitchForVec(ship, ship:velocity:orbit), shipPitch + 10).
  }
  if apoapsis < goalHeight / 4 {
    return 90 - 30 * apoapsis / (goalHeight / 4).
  }
  return clamp(45, shipPitch - 2.5, shipPitch + 2.5).
}

function hasFlameout {
  if maxThrust = 0 {
    return true.
  }
  local engs is 0.
  list engines in engs.
  for eng in engs {
    if eng:ignition and eng:flameout and not eng:multiMode {
      return true.
    }
  }
  return false.
}

local launchHeading is 90 - inclination.
local launchAltitude is body:atm:height + 10000.
if rendezvous {
	set launchAltitude to target:orbit:semiMajorAxis - body:radius.
}

set ship:control:pilotmainthrottle to 0.
lock throttle to 1.
wait until verticalSpeed > 10.

local lock lookAt to heading(launchHeading, 90).
local lock lookUp to heading(launchHeading, -45).
lock steering to lookdirup(lookAt:vector, lookUp:vector).

if body:atm:exists {
  wait until verticalSpeed > 50.
  lock targetPitch to goalPitch().
  lock lookAt to heading(launchHeading, launchPitch()).

  until altitude > body:atm:height {
    set warp to 0.
    wait until warp = 0.
    lock throttle to 1.
    until apoapsis > launchAltitude {
      wait until apoapsis > launchAltitude or hasFlameout().
      until not hasFlameout() {
        wait 2.
        stage.
      }
    }
    lock throttle to 0.
    wait until altitude > body:atm:height or apoapsis < body:atm:height + 5000.
  }
} else {
	wait until apoapsis > altitude + 1000 - alt:radar.
  lock lookAt to heading(launchHeading, 22.5).
  wait until apoapsis > launchAltitude.
}

lock throttle to 0.

if rendezvous {
	run dd_rendezvous.
} else {
  local goalSemiMajorAxis is body:radius + apoapsis.
  local initialVelocity is orbitalVelocity(ship, apoapsis).
  local goalVelocity is orbitalVelocity(ship, apoapsis, goalSemiMajorAxis).
  local deltaV is goalVelocity - initialVelocity.

  local burnTime is deltaVBurnTime(deltaV).
  lock burnStartTime to time:seconds + eta:apoapsis - burnTime / 2.

  print "burn time: " + round(burnTime) + " dV:" + round(deltaV).

  wait until time:seconds >= burnStartTime - 30.
  set warp to 0.
  lock burnPitch to -pitchForVec(ship, ship:prograde:forevector).
  lock steering to lookdirup(heading(launchHeading, burnPitch):vector, heading(launchHeading, -45):vector).

  wait until time:seconds >= burnStartTime.
  steerToDir().
  lock throttle to 1.

  wait until obt:semiMajorAxis >= goalSemiMajorAxis.

  lock throttle to 0.
  unlock steering.
  unlock throttle.
}
