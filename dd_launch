// launch.ks - Launch into a parking suborbital trajectory.
// Copyright Â© 2015 jacob berkman
// This file is distributed under the terms of the MIT license.

@lazyglobal off.

run once lib_dd.

clearscreen.
print "DunaDirect Launch! v2.3".

local undefined is "$UNDEFINED$".

parameter arg0key is undefined,
  arg0value is undefined,
  arg1key is undefined,
  arg1value is undefined,
  arg2key is undefined,
  arg2value is undefined,
  arg3key is undefined,
  arg3value is undefined,
  arg4key is undefined,
  arg4value is undefined.

local args is lexicon(arg0key, arg0value, arg1key, arg1value, arg2key, arg2value, arg3key, arg3value, arg4key, arg4value).

function orbitalVelocity {
  parameter orbitable.
  parameter altitude.
  parameter a is orbitable:obt:semiMajorAxis.
  local r is altitude + orbitable:body:radius.
  return sqrt(orbitable:body:mu * ((2 / r) - (1 / a))).  
}

function launchPitch {
  local shipPitch is pitchForVec(ship, ship:velocity:surface).
  local goalHeight is 6 * body:atm:height / 7.
  if apoapsis > goalHeight / 2 {
    local pitch is 90 - 90 * min(1.05, 0.5 + (apoapsis - goalHeight / 2) / goalHeight).
    return clamp(pitch, -8 * pitchForVec(ship, ship:velocity:orbit), shipPitch + 10).
  }
  if apoapsis < goalHeight / 4 {
    return 90 - 30 * apoapsis / (goalHeight / 4).
  }
  return clamp(45, shipPitch - 2.5, shipPitch + 2.5).
}

function hasFlameout {
  local hasEngine is false.
  local hasUllage is false.
  local engs is 0.
  list engines in engs.
  for eng in engs {
    if eng:title:contains("ullage") or eng:title:contains("sepratron") or eng:tag:contains("ullage") {
      set hasUllage to hasUllage or eng:ignition.
    } else if eng:ignition and eng:flameout and not eng:multiMode {
      return true.
    } else if eng:ignition {
      set hasEngine to true.
    }
  }
  return maxThrust = 0 or (hasUllage and not hasEngine).
}

local launchHeading is 90.
if args:hasKey("inc") {
  set launchHeading to 90 - args["inc"].
}

local rendezvous is false.
if args:hasKey("rdv") {
  set rendezvous to args["rdv"].
}

local launchAltitude is body:atm:height + 10000.
if rendezvous {
	set launchAltitude to target:orbit:semiMajorAxis - body:radius.
}
if args:hasKey("alt") {
  set launchAltitude to args["alt"] * 1000.  
}

print "Launch Configuration:".
print "Altitude: " + launchAltitude / 1000.
print "Inclination: " + (90 - launchHeading).
print "Rendezvous: " + rendezvous.

set ship:control:pilotmainthrottle to 0.
sas on.
if status = "prelaunch" {
  local preIgnite is false.
  for module in ship:modulesNamed("LaunchClamp") {
    if module:part:stage < stage:number - 1 {
      set preIgnite to true.
      break.
    }
  }
  print "T -".
  from { local count is 30. } until count = 0 step { set count to count - 1. wait 1. } do {
    print count + " " at(4, 5).
    if count = 15 {
      set warp to 0.
    }
    if count <= 10 {
      print char(7).
    }
    if preIgnite and count = 3 {
      print "Ignition.".
      global tIgnition is time:seconds.
      lock throttle to (time:seconds - tIgnition) / 4 + 0.5.
      stage.
    }
  }
  print 0 at(4, 1).
  stage.
  print "Liftoff!".
}
lock throttle to 1.
wait until verticalSpeed > 10.
sas off.
local lock lookAt to heading(launchHeading, 90).
local lock lookUp to heading(launchHeading, -45).
lock steering to lookdirup(lookAt:vector, lookUp:vector).

if body:atm:exists {
  wait until verticalSpeed > 50.
  lock targetPitch to goalPitch().
  lock lookAt to heading(launchHeading, launchPitch()).

  until altitude > body:atm:height {
    set warp to 0.
    wait until warp = 0.
    lock throttle to 1.
    until apoapsis > launchAltitude {
      wait until apoapsis > launchAltitude or hasFlameout().
      if hasFlameout() {
        wait 1.
      }
      until not hasFlameout() {
        wait 1.
        stage.
        wait 1. // give KW rockets time to spool up
      }
    }
    lock throttle to 0.
    wait until altitude > body:atm:height or apoapsis < body:atm:height + 5000.
  }
} else {
	wait until apoapsis > altitude + 1000 - alt:radar.
  lock lookAt to heading(launchHeading, 22.5).
  wait until apoapsis > launchAltitude.
}

lock throttle to 0.

if rendezvous {
	run dd_rendezvous.
} else {
  local goalSemiMajorAxis is body:radius + apoapsis.
  local initialVelocity is orbitalVelocity(ship, apoapsis).
  local goalVelocity is orbitalVelocity(ship, apoapsis, goalSemiMajorAxis).
  local deltaV is goalVelocity - initialVelocity.

  local burnTime is deltaVBurnTime(deltaV).
  lock burnStartTime to time:seconds + eta:apoapsis - burnTime / 2.

  print "burn time: " + round(burnTime) + " dV:" + round(deltaV).

  wait until time:seconds >= burnStartTime - 30.
  set warp to 0.
  lock burnPitch to -pitchForVec(ship, ship:prograde:forevector).
  lock burnHeading to compassForVec(ship, ship:prograde:forevector).
  lock steering to lookdirup(heading(burnHeading, burnPitch):vector, heading(burnHeading, -45):vector).

  wait until time:seconds >= burnStartTime.
  steerToDir().
  lock throttle to 1.

  wait until obt:semiMajorAxis >= goalSemiMajorAxis.

  lock throttle to 0.
  unlock steering.
  unlock throttle.
}
