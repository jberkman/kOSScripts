// rendezvous.ks - Perform rendezvous to target.
// Copyright Â© 2015 jacob berkman
// This file is distributed under the terms of the MIT license.

@lazyglobal off.

clearscreen.
print "DunaDirect Rendezvous! v1.9".

run lib_duna_direct.

lock greenCircle to target:velocity:orbit - ship:velocity:orbit.
lock pinkTriangle to -target:direction:vector.
lock dAng to abs(vAng(greenCircle, pinkTriangle)).

//print "dAng: " + dAng.
//print "angMult: " + angMult.

//print "pitch: green: " + greenPitch + " pink: " + pinkPitch.
//print "delta: " + (pinkPitch - greenPitch).

//print "heading: green: " + greenHeading + " pink: " + pinkHeading.
//print "delta: " + (pinkHeading - greenHeading).

function goalDir {
	local gc is greenCircle.
	local pt is pinkTriangle.

	local greenPitch is pitchForVec(ship, gc).
	local pinkPitch is pitchForVec(ship, pt).

	local greenHeading is compassForVec(ship, gc).
	local pinkHeading is compassForVec(ship, pt).

	local ang is abs(vAng(gc, pt)).
	local angMult is min(90, 2 * dAng) / dAng.

	//print "ang: " + ang + " x " + angMult.

	return lookDirUp(heading(greenHeading + angMult * (greenHeading - pinkHeading), greenPitch + angMult * (greenPitch - pinkPitch)):vector, target:up:vector).
}

function maxOutput {
	if target:distance > 5000 or dAng > 90 {
		return 1.
	} else if target:distance > 1000 {
		return 0.25.
	} else {
		return 0.1.
	}
}

//lock goalDir to lookDirUp(heading(greenHeading + angMult * (greenHeading - pinkHeading), greenPitch + angMult * (greenPitch - pinkPitch)), target:up:vector).

lock steering to goalDir().

lock goalVelocity to target:distance / 100.
local goalDistance is 128000.
global rendezvousPID to PIDLoop(1, 0, 0, 0, 1).
until target:distance < 250 {
	print "Next checkpoint: " + goalDistance + "m".
	wait until target:distance < goalDistance or dAng > 90.
	set rendezvousPID:maxOutput to maxOutput().
	if dAng > 90 {
		set warp to 0.
		print "Steering.".
		lock steering to greenCircle.
		steerToVec().
		print "Zeroing relative velocity.".
		lock throttle to rendezvousPID:update(time:seconds, -greenCircle:mag).
		wait until dAng < 45 and greenCircle:mag < 10.
		print "Re-acquiring rendezvous.".
		lock steering to target:direction.
		steerToDir().
		lock throttle to rendezvousPID:update(time:seconds, greenCircle:mag - goalVelocity).
		wait until dAng < 90 and greenCircle:mag > goalVelocity / 2.
		set goalDistance to 128000 * 2.
		lock steering to goalDir().
	} else if greenCircle:mag > goalVelocity {
		set warp to 0.
		steerToDir().
		print "Slowing to: " + (goalDistance / 100) + "m/s".
		lock throttle to rendezvousPID:update(time:seconds, goalVelocity - greenCircle:mag).
		wait until greenCircle:mag < goalVelocity * 1.05 or dAng > 90.
	}
	set goalDistance to goalDistance / 2.
	lock throttle to 0.
}

print "Killing relative velocity.".
lock steering to greenCircle.
steerToVec().
set rendezvousPID:maxOutput to 0.05.
lock throttle to rendezvousPID:update(time:seconds, -greenCircle:mag).
wait until abs(greenCircle:mag) < 0.2.

unlock steering.
unlock throttle.

print "Rendezvous complete.".
